<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>印刷物AR 完成版（回転方式2種）</title>

  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

  <style>
    body { margin:0; overflow:hidden; font-family:sans-serif; }

    #ui {
      position: fixed;
      top: 10px;
      left: 0;
      right: 0;
      text-align: center;
      z-index: 999;
    }

    #ui button {
      font-size: 14px;
      padding: 6px 10px;
      margin: 4px;
    }

    #debugUI {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 10px;
      border-radius: 10px;
      font-size: 12px;
      z-index: 999;
    }

    #debugUI label { display:block; margin-top:6px; }
    #debugUI input { width:100%; }
  </style>
</head>

<body>

<!-- ===== UI ===== -->
<div id="ui">
  <button onclick="showImage()">画像</button>
  <button onclick="showModel()">3D</button>
  <button onclick="modeSelf()">その場回転</button>
  <button onclick="modeOrbit()">棒回転</button>
</div>

<a-scene embedded arjs="sourceType: webcam;">
  <a-marker type="pattern" url="assets/markers/pattern-ROBOTA.patt">

    <a-image
      id="image"
      src="assets/images/3.png"
      width="1"
      height="1"
      rotation="-90 0 0"
      position="0 0 0.01"
      visible="true">
    </a-image>

    <!-- ===== 回転用ピボット（棒） ===== -->
    <a-entity id="pivot" rotation="0 0 0">

      <!-- 3Dモデル本体 -->
      <a-entity
        id="model"
        gltf-model="assets/models/Pumpkin.glb"
        position="0 -0.6 0.4"
        rotation="-95 180 0"
        scale="0.15 0.15 0.15"
        visible="false">
      </a-entity>

    </a-entity>

  </a-marker>

  <a-entity camera></a-entity>
</a-scene>

<div id="debugUI">
  <label>回転Y
    <input type="range" id="rotY" min="0" max="360" value="180">
  </label>
</div>

<script>
  const image = document.querySelector('#image');
  const model = document.querySelector('#model');
  const pivot = document.querySelector('#pivot');
  const rotY = document.querySelector('#rotY');

  let currentRotY = 180;
  let rotationMode = 'self'; // self | orbit

  function showImage() {
    image.setAttribute('visible', true);
    model.setAttribute('visible', false);
  }

  function showModel() {
    image.setAttribute('visible', false);
    model.setAttribute('visible', true);
  }

  function modeSelf() {
    rotationMode = 'self';
  }

  function modeOrbit() {
    rotationMode = 'orbit';
  }

  function updateRotation() {
    if (rotationMode === 'self') {
      model.setAttribute('rotation', `-95 ${currentRotY} 0`);
      pivot.setAttribute('rotation', '0 0 0');
    } else {
      pivot.setAttribute('rotation', `0 ${currentRotY} 0`);
      model.setAttribute('rotation', '-95 180 0');
    }
  }

  rotY.oninput = () => {
    currentRotY = Number(rotY.value);
    updateRotation();
  };

  /* ===== ドラッグ＋慣性 ===== */
  let isDragging = false;
  let lastX = 0;
  let velocity = 0;
  const friction = 0.94;

  function start(x) {
    isDragging = true;
    lastX = x;
    velocity = 0;
  }

  function move(x) {
    if (!isDragging) return;
    const dx = x - lastX;
    lastX = x;
    velocity = dx * 0.6;
    currentRotY += velocity;
    rotY.value = currentRotY;
    updateRotation();
  }

  function end() { isDragging = false; }

  function inertia() {
    if (!isDragging && Math.abs(velocity) > 0.1) {
      velocity *= friction;
      currentRotY += velocity;
      rotY.value = currentRotY;
      updateRotation();
    }
    requestAnimationFrame(inertia);
  }
  inertia();

  window.addEventListener('mousedown', e => model.getAttribute('visible') && start(e.clientX));
  window.addEventListener('mousemove', e => move(e.clientX));
  window.addEventListener('mouseup', end);

  window.addEventListener('touchstart', e => model.getAttribute('visible') && start(e.touches[0].clientX));
  window.addEventListener('touchmove', e => move(e.touches[0].clientX));
  window.addEventListener('touchend', end);
</script>

</body>
</html>






















































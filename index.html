<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>印刷物AR 完成版（サイズ＆正面調整）</title>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body { margin:0; overflow:hidden; font-family:sans-serif; }
    #ui { position: fixed; top: 10px; left: 0; right: 0; text-align: center; z-index: 999; }
    #ui button { font-size: 14px; padding: 8px 12px; margin: 4px; background: white; border: 1px solid #ccc; border-radius: 4px; }
    
    #debugUI {
      position: fixed; bottom: 20px; left: 20px; right: 20px;
      background: rgba(0,0,0,0.7); color: white; padding: 15px; border-radius: 10px; font-size: 14px; z-index: 999;
    }
    #debugUI label { display:block; margin-bottom:8px; }
    #debugUI input { width:100%; cursor: pointer; margin-bottom: 10px; }
  </style>
</head>

<body>

<div id="ui">
  <button onclick="showImage()">画像表示</button>
  <button onclick="showModel()">3Dモデル</button>
  <button onclick="modeSelf()">その場回転</button>
  <button onclick="modeOrbit()">棒回転</button>
</div>

<a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;">
  <a-marker type="pattern" url="assets/markers/pattern-ROBOTA.patt">

    <a-image id="image" src="assets/images/3.png" width="1" height="1" rotation="-90 0 0" position="0 0.05 0" visible="true"></a-image>

    <a-entity id="pivot" rotation="0 0 0">
      <a-entity
        id="model"
        gltf-model="assets/models/Pumpkin.glb"
        position="0 0 0" 
        rotation="-90 0 0" 
        scale="0.15 0.15 0.15"
        visible="false">
      </a-entity>
    </a-entity>

  </a-marker>
  <a-entity camera></a-entity>
</a-scene>

<div id="debugUI">
  <label id="rotLabel">回転角度: 0°</label>
  <input type="range" id="rotY" min="0" max="360" value="0">

  <label id="scaleLabel">大きさ: 0.15</label>
  <input type="range" id="scaleSld" min="0.01" max="0.5" step="0.01" value="0.15">
</div>

<script>
  const model = document.querySelector('#model');
  const image = document.querySelector('#image');
  const pivot = document.querySelector('#pivot');
  const rotY = document.querySelector('#rotY');
  const scaleSld = document.querySelector('#scaleSld');
  const rotLabel = document.querySelector('#rotLabel');
  const scaleLabel = document.querySelector('#scaleLabel');

  // 【重要】モデルの顔を正面にするためのオフセット角度
  // 0で横を向く場合はここを 90 や -90 に書き換えて調整してください
  const FACE_OFFSET = 0; 

  let currentRotY = 0;
  let currentScale = 0.15;
  let rotationMode = 'self';

  function showImage() { image.setAttribute('visible', true); model.setAttribute('visible', false); }
  function showModel() { image.setAttribute('visible', false); model.setAttribute('visible', true); }
  function modeSelf() { rotationMode = 'self'; updateTransform(); }
  function modeOrbit() { rotationMode = 'orbit'; updateTransform(); }

  // 回転と大きさを同時に更新
  function updateTransform() {
    rotLabel.innerText = `回転角度: ${Math.floor(currentRotY % 360)}°`;
    scaleLabel.innerText = `大きさ: ${currentScale.toFixed(2)}`;

    // 大きさの反映
    model.setAttribute('scale', `${currentScale} ${currentScale} ${currentScale}`);
    
    // 回転の反映（FACE_OFFSETを足すことで正面を調整）
    const finalRotY = currentRotY + FACE_OFFSET;

    if (rotationMode === 'self') {
      model.setAttribute('rotation', `-90 ${finalRotY} 0`);
      pivot.setAttribute('rotation', '0 0 0');
    } else {
      pivot.setAttribute('rotation', `0 ${currentRotY} 0`);
      model.setAttribute('rotation', `-90 ${FACE_OFFSET} 0`);
    }
  }

  // スライダー操作
  rotY.oninput = () => { currentRotY = Number(rotY.value); updateTransform(); };
  scaleSld.oninput = () => { currentScale = Number(scaleSld.value); updateTransform(); };

  /* ===== ドラッグ操作 ===== */
  let isDragging = false;
  let lastX = 0;
  let velocity = 0;

  function start(x) { if (!model.getAttribute('visible')) return; isDragging = true; lastX = x; velocity = 0; }
  function move(x) {
    if (!isDragging) return;
    const dx = x - lastX;
    lastX = x;
    velocity = dx * 0.5;
    currentRotY += velocity;
    rotY.value = currentRotY % 360;
    updateTransform();
  }
  function end() { isDragging = false; }

  function inertia() {
    if (!isDragging && Math.abs(velocity) > 0.1) {
      velocity *= 0.94;
      currentRotY += velocity;
      rotY.value = currentRotY % 360;
      updateTransform();
    }
    requestAnimationFrame(inertia);
  }
  inertia();

  window.addEventListener('mousedown', e => start(e.clientX));
  window.addEventListener('mousemove', e => move(e.clientX));
  window.addEventListener('mouseup', end);
  window.addEventListener('touchstart', e => start(e.touches[0].clientX));
  window.addEventListener('touchmove', e => move(e.touches[0].clientX));
  window.addEventListener('touchend', end);

</script>
</body>
</html>



















































